# Python Basic Syntax 2

## list
### 여러 개의 값을 순서대로 저장하는, 변경 가능한 시퀀스 자료
- 대괄호 [] 안에 값들을 쉼표(,)로 구분하여 만듦
- 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
- 값을 추가, 수정, 삭제하는 등 자유롭게 변경할 수 있음
- 리스트도 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능
### 중첩 리스트(Nested List)
- 다른 리스트를 값으로 가진 리스트
- 인덱스를 연달아 사용하여 안쪽 리스트 값에 접근할 수 있음
```
# 중첩된 리스트 접근
my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
print(len(my_list))  # 5
print(my_list[4][-1])  # !!!
print(my_list[-1][1][0])  # w
```   
1. 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택
        - my_list[4] -> ['hello', 'world', '!!!']
2. 선택된 안쪽 리스트에 다시 한번 인덱스를 사용
        - my_list[4][-1] -> '!!!'
### 리스트는 **변경가능한** 시퀀스 자료형
1. 인덱싱으로 값 수정하기  
```
my_list = [1, 2, 3, 4, 5]
my_list[1] = 'two'
print(my_list) #[1, 'two', 3, 4, 5]
```
2. 슬라이싱으로 여러 값 한번에 바꾸기
```
my_list = [1, 2, 3, 4, 5]
my_list[2:4] = ['three', 'four']
print(my_list) #[1, 2, 'three', 'four', 5]
```
## tuple
### 여러 개의 값을 순서대로 저장하는 변경 불가능한 시퀀스 자료형
- 소괄호 () 안에 값들을 쉼표(,)로 구분하여 만듦
- 모든 종류의 데이터를 담을 수 있음
- 리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적 차이 존재
- **소괄호없이도 만들 수 있음**
-**단일 요소 튜플을 만들 때는 반드시 후행 쉼표 사용해야 함**
- 튜플 역시 시퀀스이므로 인덱싱, 슬라이싱 등 공통 기능 모두 사용 가능
### 튜플의 불변성
- 한번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제 불가
- 내부 동작과 안전한 데이터 전달에 사용됨
- 다중 할당, 값, 교환, 함수 다중 반환 값 등

<튜플은 문제에서 사용하지 않을 것이므로 이정도만 알아두기>
## range
### 연속된 정수 시퀀스를 생성하는, 변경 불가능한 자료형
- 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용
- 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리를 효율적으로 사용
### range 기본 구문
- range()는 1개, 2개, 또는 3개의 매개변수를 가질 수 있음
```
range(start, stop, step)
```
```
# range 표현
my_range_1 = range(5)
my_range_2 = range(1, 10)
my_range_3 = range(5, 0, -1)

print(my_range_1)  # range(0, 5)
print(my_range_2)  # range(1, 10)
print(my_range_3)  # range(5, 0, -1)

# 리스트로 형 변환 시 데이터 확인 가능
print(list(my_range_1))  # [0, 1, 2, 3, 4]
print(list(my_range_2))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list(my_range_3))  # [5, 4, 3, 2, 1]
```
range(stop)
- 매개변수가 하나면 stop으로 인식
- start는 0이, step은 1이 기본값으로 자동 설정
- range(5) => 0, 1, 2, 3, 4

range(start, stop)
- 매개변수가 두 개면 start와 stop으로 인식
- step은 1이 기본값으로 자동 설정
- range(2,5) => 2, 3, 4

range(start, stop, step)
- 모든 매개변수를 직접 지정
- range(2, 10, 2) => 2, 4, 6, 8
### range의 규칙
1. 값의 범위 규칙
    - stop 값은 생성되는 시퀀스에 절대 포함되지 않음
    - range(1, 5)는 1부터 5 **'전'**까지의 숫자를 의미하므로 1, 2, 3, 4가 생성
2. 증가/감소 규칙
    - step 값은 숫자 시퀀스의 간격과 방향을 결정
    1. step이 양수일 때(기본값 : 1)
        - 숫자가 start부터 stop을 향해 증가
        - range(1, 10, 2) => 1, 3, 5, 7, 9
    2. step이 음수일 때
        - 숫자가 start부터 stop을 향해 감소
        - 이 경우, start 값은 stop 값보다 반드시 커야 함
        - range(10, 1, -2) => 10, 8 6, 4, 2

<주로 반복문과 함께 활용 예정>

## dict
### key - value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형
- 중괄호 {} 안에 값들이 쉼표(,)로 구분되어 있음
- 값 1개는 키와 값이 쌍으로 이루어져 있음
- key(키)
    - 값을 식별하기 위한 고유한 '이름표'(중복 불가)
- Value(값)
    - 키에 해당하는 실제 데이터
- 각 값에는 **순서가 없음**
- 딕셔너리는 순서가 없는 자료형이지만 파이썬 3.7 이상에서는 입력한 순서는 출력 시 그래도 유지
- 그러나 여전히 딕셔너리의 핵심은 **순서가 없는 자료형**이라는 점과 **key를 통한 접근**이라는 점을 기억해야 함
```
# 딕셔너리 표현
my_dict_1 = {}
my_dict_2 = {'key': 'value'}  # 단일 키-값 쌍
my_dict_3 = {'apple': 12, 'list': [1, 2, 3]}  # 여러 키-값 쌍

print(my_dict_1)  # {}
print(my_dict_2)  # {'key': 'value'}
print(my_dict_3)  # {'apple': 12, 'list': [1, 2, 3]}
```
### 딕셔너리 규칙
#### Key의 규칙
- 고유해야 함
    - Key는 중복될 수 없음
- 변경 불가능한 자료형만 사용 가능
    - O(가능) : str, int, float, tuple
    - X(불가능) : list, dict
#### Value의 규칙
- 어떤 자료형이든 자유롭게 사용 가능

### 딕셔너리 값 접근
- Key를 사용하여 해당 Value를 꺼내올 수 있음
- Key에 접근 시 대괄호 [] 사용
```
# 딕셔너리는 키에 접근해 값을 얻어냄
my_dict = {'name': '홍길동', 'age': 25}
print(my_dict['name'])  # '홍길동'
print(my_dict['test'])  # KeyError: 'test'
```
- 존재하지 않는 Key로 접근하면 KeyError가 발생하며 프로그램이 멈춤
- 사전에서 단어를 찾아 뜻을 확인하는 것처럼 딕셔너리는 Key를 통해 Value에 빠르게 접근
### 딕셔너리 값 추가 및 변경
```
# 딕셔너리 값 추가 및 변경
my_dict = {'apple': 12, 'list': [1, 2, 3]}
# 추가
my_dict['banana'] = 50
print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}

# 변경
my_dict['apple'] = 100
print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
```
## set
### 순서와 중복이 없는 변경 가능한 자료형
- 중괄호 {} 안에 값들을 쉼표(,)로 구분하여 만듦
- 수학에서의 집합과 동일한 연산 처리 가능
```
my_set_1 = set()  # 빈 세트
my_set_2 = {1, 2, 3}  # 여러 요소를 가진 세트   
my_set_3 = {1, 1, 1}  # 중복된 요소는 하나로 처리됨

print(my_set_1)  # set()
print(my_set_2)  # {1, 2, 3}
print(my_set_3)  # {1}
```
### 세트의 두 가지 핵심 특징
1. 중복을 허용하지 않음
    - 똑같은 값은 단 하나만 존재 가능
2. 순서가 없음
    - 인덱싱이나 슬라이싱을 사용할 수 없음
## 세트의 집합 연산
- 세트는 수학의 '집합' 개념을 그대로 가져와, 두 데이터 그룹 간의 관계를 파악하는 데에 매우 효과적
```
# 세트의 집합 연산산
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

# 교집합
print(my_set_1 & my_set_2)  # {3}
```
## Other Types
### None
- 파이썬에서 **'값이 없음'**을 표현하는 특별한 데이터 타입
- 마치 내용물이 없는 '빈 상자'와 같음
- 숫자 0이나 빈 문자열('')과는 다른, **'값이 존재하지 않음'** 또는 **'아직 정해지지 않음'**이라는 상태를 나타내기 위해 사용
```
# None
my_variable = None
print(my_variable)  # None
# 무조건 대문자 N을 사용해야 함
```
### Boolean
- '참'과 '거짓', 단 두 가지 값만 가지는 데이터 타입
- 비교/논리 연산의 평가 결과로 사용됨
- 주로 조건/반복문과 함께 사용할 예정
```
# Boolean
is_active = True
is_logged_in = False

print(is_active)  # True
print(is_logged_in)  # False
print(10 > 5)  # True
print(10 == 5)  # False
# 마찬가지로 대문자 B를 사용해야 함
```
## Collection
- **여러 개의 값을 하나로 묶어 관리**하는 자료형들을 통칭하는 말
## 불변과 가변
- 컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 '불변'과 '가변' 두 그룹으로 나뉨
    - 불변 : str, tuple, range
    - 가변 : list, dict, set
```
# immutable (불변)
my_str = 'hello'
my_str[0] = 'z'  # TypeError: 'str' object does not support item assignment

# mutable (가변)
my_list = [1, 2, 3]
my_list[0] = 100
print(my_list)  # [100, 2, 3]
```
## 형변환
- 한 데이터 타입을 **다른 데이터 타입으로 변환**하는 과정
    1. 암시적 형변환 : 파이썬이 **자동으로** 처리
    2. 명시적 형변환 : 개발자가 **직접** 지시
### 암시적 형변환
- 파이썬이 연산 중에 **자동으로 데이터 타입을 변환**하는 것
- 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙
- 마치 작은 '정수 상자'와 큰 '실수 상자'의 내용물을 합칠 때, 더 안전하게 담을 수 잇는 큰 '실수 상자'로 알아서 옮겨 담는 것
- 개발자가 신경쓰지 않아도 "더 안전한 쪽으로" 파이썬이 처리해주는 것
```
# 암시적 형변환
# 정수(int)와 실수(float)의 덧셈
print(3 + 5.0)  # 8.0
# 불리언(bool)과 정수(int)의 덧셈
print(True + 3)  # 4
# 불리언간의 덧셈
print(True + False)  # 1
```
### 명시적 형변환
- 개발자가 변환하고 싶은 타입을 **직접 함수로 지정**하여 변환하는 것
- 서로 다른 타입의 데이터를 '호환'되도록 맞추는 과정
- 마치 해외에서 다른 모양의 전기 콘센트에 맞는 '어댑터'를 끼우는 것
- 파이썬은 타입에 엄격해서, 정수와 문자열을 바로 더할 수 없는 것처럼 모양이 다른 플러그는 바로 연결 불가능
```
# 명시적 형변환
# str -> int
# 형식에 맞는 숫자만 가능
print(int('1'))  # 1
# ValueError: invalid literal for int() with base 10: '3.5'
# print(int('3.5'))
print(int(3.5))  # 3
print(float('3.5'))  # 3.5

# int -> str
# 모두 가능
print(str(1) + '등')  # 1등
```
## 연산자
### 산술 연산자
- 수학적 계산을 위해 사용되는 연산자
### 복합 연산자
- 연산과 할당이 함께 이뤄짐
```
# 복합 연산자
y = 10
y -= 4
# y = y - 4
print(y)  # 6

z = 7
z *= 2
print(z)  # 14

w = 15
w /= 4
print(w)  # 3.75

q = 20
q //= 3
print(q)  # 6
```
### 비교 연산자
- 두 값을 비교하여 그 관계가 맞는지 틀리는지를 True 또는 False로 반환
### '== vs 'is' **구분**
#### == 연산자
- 값(데이터)이 같은지를 비교
- 동등성
#### is 연산자
- 객체 자체가 같은지를 비교
- 식별성
- 두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용
### is 대신 ==를 사용해야 하는 이유
- 결론 : is는 '정체성'을 ==는 '가치'를 비교하기 때문
- 두 연산자는 "같다"를 확인하는 목적이 근본적으로 다름
- is
    - 두 변수가 완전히 동일한 메모리 주소의 객체를 가리키는지, 즉 '정체성'이 같은지를 확인
- == 
    - 두 변수가 가리키는 객체의 내용, 즉 '값'이 같은지를 확인

### 정리
- 값 비교에는 ==을 사용하고, 객체 비교에는 is를 사용하는 것이 원칙
- 숫자나 문자열, 불리언 값 등 동등성(값)을 판단해야 할 때 is를 쓰면 의도치 않은 결과(False)가 나올 수 있으며, 이는 파이썬 내부적인 최적화나 타입 차이로 인해 일관성이 깨질 수 있기 때문
- is는 주로 싱글턴 객체에 대한 비교 시 사용
### 논리 연산자
- 여러 개의 조건을 조합하거나, True/False 값을 반대로 뒤집을 때 사용(and, or, not이 대표적)
```
# 논리 연산자
print(True and False)  # False
print(True or False)  # True
print(not True)  # False
print(not 0)  # True

# 논리 연산자 & 비교 연산자와 함께 사용 가능
num = 15
result = (num > 10) and (num % 2 == 0)
print(result)  # False

name = 'Alice'
age = 25
result = (name == 'Alice') or (age == 30) => 하나가 True면 True이므로 뒤는 보지 않음 -> 단축 평가
print(result)  # True
```
### 단축 평가
-논리 연산에서 **두 번째 피연산자를 평가하지 않고 결과를 결정**하는 동작
- 거짓으로 취급되는 값들
    - False, 숫자 0, 빈 문자열 "", 빈 리스트[], None 등 '비어있거나 없다'는 느낌의 값들
- 참으로 취급되는 값들
    - True, 그리고 '거짓'이 아닌 모든 값
    - 1, -10, "hello", [1, 2] 등 내용이 있는 값
- and 연산자 : 하나라도 '거짓'이면 '거짓'
    - and는 연산을 왼쪽에서 오른쪽으로 진행하다가 처음 만나는 '거짓' 값을 바로 반환
```
# 단축 평가

# 1
# 준비물 1: 내용이 있는 문자열
item1 = '지도'
# 준비물 2: 내용이 있는 문자열
item2 = '나침반'
result = item1 and item2
print(f'최종적으로 챙긴 물건: {result}')
# >> 최종적으로 챙긴 물건: ??

# 2
item1 = '지도'
# 준비물 2: 내용이 없는 빈 문자열
item2 = ''
result = item1 and item2
print(f'최종적으로 챙긴 물건: "{result}"')
# >> 최종적으로 챙긴 물건: ??


# 3
# 준비물 1: 내용이 없는 빈 문자열
item1 = ''
item2 = '나침반'
result = item1 and item2
print(f'최종적으로 챙긴 물건: "{result}"')
# >> 최종적으로 챙긴 물건: ??
```
- or 연산자 : 하나라도 '참'이면 바로 '참'
    - or는 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 '참' 값을 바로 반환
#### 단축 평가를 하는 이유
- 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 하기 위함
### 멤버십 연산자
- 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
```
# 멤버십 연산자

word = 'hello'
numbers = [1, 2, 3, 4, 5]

print('h' in word)  # True
print('z' in word)  # False

print(4 not in numbers)  # False
print(6 not in numbers)  # True
```
### 시퀀스 연산자
- 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자
- '+'는 시퀀스를 연결하는 기능을, '*'는 시퀀스를 반복하는 기능을 함
```
# 시퀀스형 연산자

print('Gildong' + ' Hong')  # Gildong Hong
print('hi' * 5)  # hihihihihi

print([1, 2] + ['a', 'b'])  # [1, 2, 'a', 'b']
print([1, 2] * 2)  # [1, 2, 1, 2]
```
## 참고(Trailing Comma)
### Trailing Comma(후행 쉼표)
- 컬렉션의 마지막 요소 뒤에 붙은 쉼표
- 일반적으로 '선택사항'
- 단, 하나의 요소로 구성된 튜플을 만들 때는 '필수사항'
- 딕셔너리에는 많이 씀
### Trailing Comma 장점
1. 가독성 향상
    - 각 줄이 동일한 패턴 가짐
    - 코드 리뷰가 용이함
2. 유지보수 용이성
    - 항목 추가/제거가 간단함
    - 실수로 인한 구문 오류 방지    